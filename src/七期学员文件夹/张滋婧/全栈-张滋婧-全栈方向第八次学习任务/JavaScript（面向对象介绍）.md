# JavaScript（面向对象介绍）

## 面向对象介绍

**面向对象编程**

* 程序是干嘛的？

  程序就是对现实世界的抽象（照片就是对人的抽象）

* 对象是干嘛的？

  一个事物抽象到程序后就变成了对象

  在程序世界中，一切皆对象

* 面向对象的编程

  面向对象的编程指，程序中所有的操作都是通过对象来完成的

  做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

### 1. 类的介绍

* **使用Object创建对象的问题**

  1. 无法区分出不同类型的对象
  2. 不方便批量创建对象

* **在JS中可以通过类（class）来解决这个问题:**

  1. 类是对象的模板，可以将对象的属性和方法直接定义在类中，定义后，就可以直接通过类来创建对象

  2. 通过同一个类创建的对象，我们称为同类对象

     * 可以使用instanceof来检查一个对象是否由某个类创建
     * 如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

  3. **语法：**

     * class 类名 { }   类名要使用大驼峰命名

       类的代码块自带严格模式

       类的代码块使用来设置对象的属性的，不是什么代码都能写

     * const 类名 =  class { }

* 通过类创建对象

  new  类 （）

  例：const p1 = new person （）

### 2. 属性

```js
class person {
    /*
    	类的代码块自带严格模式
		类的代码块使用来设置对象的属性的，不是什么代码都能写
    */
    /*
    	当我们在类中直接指定实例属性的值时，意味着我们创建的所有对象的属性都是这个值
    */
    name = "孙悟空" //person的实例属性name p1.name
    age = 18       //实例属性只能通过实例访问 p1.age
    
    
    static test = "test静态属性"  //使用static声明的属性，是静态属性（类属性） person.test
    static hh = "静态属性"  //静态属性只能通过类去访问  person.hh
}
```

### 3. 方法

```js
class person g
    name = "孙悟空"
    
    sayHello = function(){
        
    }  //添加方法的一种方式
    
    sayHello(){
        console.log("大家好，我是" + this.name)
    }  //添加方法（实例方法）实例方法中this就是当前实例 p1.sayHe 
    
    static test(){
        console.log("我是静态方法"，this)
    }  //静态方法（类方法）通过类来调用 静态方法中this值得是当前类 person.test
}
const p1 = new person()
```

### 4. 构造函数

```js
class person {
    
    // 在类中可以添加一个特殊的方法constructor
    // 该方法我们称为构造函数（构造方法）
    // 构造函数会在我们调用类创建对象时执行
    constructor(name,age,gender){
        // console.log("构造函数执行了~",name,age,gender)
        // 可以在构造函数中，为实例属性进行赋值
        // 在构造函数中，this表示当前所创建的对象
        this.name = name
        this.age = age
        this.gender = gender
        
    }
}

const p1 = new Person("孙悟空",18,"男")
const p2 = new person("猪八戒",18,"男")
```

### 5. 面向对象的特点

* **特点**：封装，继承和多态

#### （1）封装 - 安全性

* 对象就是一个用来储存不同属性的容器

* 对象不仅负责存储属性还要负责数据的安全

* 直接添加到对象中的属性，并不安全，因为他们可以任意的被修改

* 如何确保数据安全：

  1. 私有化数据：将需要保护的数据设置为私有，只能在类内部使用

  2. 提供setter和getter方法来开放对数据的操作

     属性设置私有，通过getter setter方法操作属性带来的好处

     * 可以控制属性的读写权限
     * 可以在方法中对属性的值进行验证

* 封装主要用来保证数据的安全

* 实现封装的方法：

  1. 属性私有化  加#

  2. 通过getter和setter方法来操作属性

     ```js
     get 属性名(){
         return this.#属性
     }
     set 属性名(参数){
         this.#属性 = 参数
     }
     ```

* ```js
  class Person {
  	// #address = "花果山"  //实例使用#开头就变成了私有属性，私有属性只能在类内部访问
      
      #name
      #age
      #gender
      
      constructor(name,age,gender){
          this.#name = name 
          this.#age = age
          this.#gender = gender
      }
      
      sayHello(){
          console.log(this.#name)
      }
      
      // getter方法用来读取属性
      getName(){
          return this.#name
      }
      
      // setter方法用来设置属性
      setName(){
          // 这里可以对输入的内容加以限制
          this.#name = name
      }
      
      get gender(){
          return this.#gender
      }
      
      set gender(gender){
          this.#gender = gender
      }
  }
  .、
  const p1 = new person("孙悟空"，18，"男")
  
  p1.setName("猪八戒")
  ```

#### （2）多态 - 灵活性

* 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递
* 要调用某个函数，无需指定类型，只要对象满足某些条件即可
* 多态为我们提供了灵活性

#### （3） 继承 - 扩展性

* 可以通过extends关键词来完成继承
* 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中（简单理解 ）
* 继承发生时，被继承的类称为 父类（超类），继承的类称为子类
* 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展



* 通过继承可以在不修改一个类的情况下对其进行扩展

* OCP开闭原则

   	程序应该对修改关闭，对扩展开放

```js
class Animal{
    constructor(name){
        this.name = name
    }
    sayHello(){
        console.log("动物在叫~")
    }
}

class Dog extends Animal{
    
    //在子类中，可以通过创建同名方法来重写父类的方法
    sayHello(){
        console.log("汪汪汪")
    }
}

class Cat extends Animal{
    
    //重写构造函数
   constructor(name){
       //重写构造函数时，构造函数的第一行代码必须为super()
       super(name)//调用父类的构造函数
   }
    
     sayHello(){
         
        //调用一下父类的sayHello
        super.sayHello()
        console.log("喵喵喵")
    }
}

const dog = new Dog("旺财")
const cat = new Cat("汤姆")

dog.sayHello()
cat.sayHello()
console.log(dog)
console.log(cat)
```

### 6. 对象的结构

* 在对象中存储属性的区域实际有两个：

  1. 对象自身
     * 比如直接通过对象所添加的属性，位于对象自身中
     * 在类中通过x = y 的形式添加的属性，位于对象自身中
     
  2. 原型对象（prototype）
     * 对象中还有一些内容存储在其他对象中（原型对象）
     
     * 在对象中会有一个属性来存储原型对象，这个属性叫做
     
       ```
       _ _proto_ _
       ```
     
     * 原型对象也负责为对象储存属性
     
       1. 当我们访问对象中的属性时，会优先访问对象自身的属性
       2. 对象
  
  

```js
class Person{
    name = '孙悟空'
    
    sayHello(){
        console.log("Hello,我是"，this.name)
    }
}

const p1 = Person()

console.log(p1)
```

### 7. 原型

* 访问一个对象的原型对象

  ```js
  1. 对象._ _proto_ _
  2. Object.getProtoytpeof(对象)
  ```

* 原型对象中的数据

  1. 对象中的数据（属性，方法等）
  2. constructor（对象的构造函数）

* 注意：

  1. 原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同

     * p对象的原型链：p对象 --> 原型  --> 原型 --> null
     * obj对象的原型链：obj对象 --> 原型 -->null

  2. 原型链

     * 读取对象属性时，会优先读取对象自身的属性

       如果对象中有则使用，没有则去对象的原型中寻找

       如果原型中有则使用，没有则去原型的原型中寻找

       直到null，如果没有找到，返回undefined

     * 作用域链，是找变量的链，找不到会报错

     * 原型链，是找属性的链，找不到会返回undefined

* **原型的作用**

  * 所以的同类型对象，他们的原型对象都是同一个，也就意味着同类型对象的原型链是一样的

  * 原型的**作用**：

    * 原型就相当于是一个公共的区域，可以被所有该类实例访问

      可以将该类实例中，所有的公共属性（方法）统一储存到原型中

      这样我们需要创建一个属性，即可被所有实例访问

    * JS中继承就是通过原型来实现的

      当继承时，子类的原型就是一个父类的实例

  * 在对象中有些值是对象独有的，像属性（name age，gender）每个对象都应该有自己的值

    但有些值对每个对象来说都是一样的，像各种方法，对于一样的值没有必要

* **修改原型**

  * 大部分情况下，我们是不需要修改原型对象

    * 注意：

      千万不要通过类的实例去修改原型

      1. 通过一个对象影响所有同类对象，这么做不合适
      2. 修改原型先得创建实例，麻烦
      3. 危险

  * 除了通过_ _ _proto_  _ _能访问对象的原型外，还可以通过类的prototype属性，来访问实例的原型

  * 修改原型，最好通过类去修改

    好处：

    * 一修改就是修改所以实例的原型
    * 无需创建实例即可完成对类的修改

    原则：

    * 原型尽量不要手动改
    * 要改也不要通过实例对象去改
    * 通过 类.prototype 属性去修改
    * 最好不要直接给prototype去赋值

### 8. instanceof 和 hasOwn

* instanceof 用来检查一个对象是否是一个类的实例

  * instanceof检查的是对象的原型链上是否有该类实例

     只要原型链上有该类实例，就会返回true

  * dog -》 Animal的实例 —》 Object实例 —》 Object原型

  * Object是所有对象的原型，所以任何对象和Object进行instanceof运算，都会返回true

* in 

  使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true

* 对象.hasOwnProperty(属性名)（不推荐使用）

   用来检查对象的自身是否含有某个属性

* Object.has(对象，属性名)

   用来检查对象的自身是否含有某个属性

### 9. 旧类

早期JS中，直接通过函数来定义类‘

* 一个函数如果直接调用 XXX() 那么这个函数就是一个普通函数
* 一个函数如果通过new调用 new XXX（） 那么这个函数就是一个构造函数

### 10. new运算符

* new运算符是创建对象时要使用的运算符

* 当使用new去调用一个函数时，这个函数将会作为构造函数调用

  会发生：

  1. 创建一个普通的JS对象（Object对象{}），为了方便，称其为新对象

  2. 将构造函数的prototype属性设置为新对象的原型

  3. 使用实参来执行构造函数，并且将新对象设置为函数中的this

  4. 如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回

     如果构造函数的返回值是一个原始值或者没有指定返回值，则新对象将会作为返回值返回

### 11.对象的分类

* 内建对象
  1. 由ES标准所定义的对象
  2. 比如 Object   Function   String   Number  ....

* 宿主对象

  1. 由浏览器提供的对象
  2. BOM  ，  DOM

* 自定义对象

  ​       由开发人员自己创建的对象
